/*
 * generated by Xtext 2.16.0
 */
package org.xtext.mixin.fanfan.generator

import java.util.HashMap
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.mixin.fanfan.mixfanf.Directive
import org.xtext.mixin.fanfan.mixfanf.Line

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MixfanfGenerator extends AbstractGenerator {
	int position = 5
	int quantity = 0
	boolean entry1 = false
	boolean entry2 = false
	boolean shut = false
	HashMap<String, String> tasks = new HashMap<String, String>()

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		fsa.generateFile(resource.URI.fileExtension + ".java", resource.compile)
	}

	def compile(Resource r) '''
		public class MixFanf {
			public void execute() {
				double i,j;
				open(0);
			«FOR l : r.allContents.toIterable.filter(Line)»
				«l.compile»
			«ENDFOR»
			}
		}
		
	'''

	def compile(Line l) {
		var s = '	'
		var k = ''
		println(l.line)
		if (l.line == 'dir') {
			for (d : l.directives) {
				s += d.compile
			}
			return s
		} else if (l.line == 'task') {
			for (d : l.task.directives) {
				k = l.task.name
				s += d.compile
			}
			tasks.put(k, s)
			return s
		} else if (l.line == 'do') {
			s = tasks.get(l.task.name)
			return s
		}
	}

	def compile(Directive d) {
		var s = '';
		if (d.instruction.order == 'go')
			s += d.move
		else if (d.instruction.order == 'stop')
			s += d.stop
		else if (d.instruction.order == 'take')
			s += d.take
		else if (d.instruction.order == 'give')
			s += d.give
		else if (d.instruction.order == 'wait')
			s += d.sleep
		else if (d.instruction.order == 'filter')
			s += d.filter
		return s
	}

	def filter(Directive d) {
		var filt = d.instruction.param.split(' ').get(0)
		var f = 0
		if (filt == 'A') f = 1
		if (filt == 'B') f = 2
		return 'filter(' + f + ');'
	}

	def sleep(Directive d) {
		var time = Integer::parseInt(d.instruction.param.split(' ').get(0))
		return 'wait(' + time + ');'
	}

	def give(Directive d) {
		var s = ''
		if (d.instruction.param.split(' ').get(0) == 'all') {
			s += 'blow(i);\n'
		} else {
			var given = Integer::parseInt(d.instruction.param.split(' ').get(0))
			quantity -= given;
			s += 'blow(' + given + ');\n'
		}
		return s += d.clean()
	}

	def clean(Directive d) {
		val relative = 4 - position
		position = 4
		var s = '	'
		s += 'move(' + relative + ');suck(30);'
		position = 5
		s += 'move(1);blow(30);'
		return s
	}

	def take(Directive d) {
		if (d.instruction.param.split(' ').get(0) == 'all') {
			return 'i=scan();suck(i);'
		} else {
			var took = Integer::parseInt(d.instruction.param.split(' ').get(0))
			quantity += took;
			return 'suck(' + took + ');'
		}
	}

	def stop(Directive d) {
		return '''if(scan()«IF d.instruction.param.split(' ').get(3) == 'different'
		»!=«ENDIF»«IF d.instruction.param.split(' ').get(3) == 'less'»<«ENDIF»«Integer::parseInt(d.instruction.param.split(' ').get(4))») return -1;
		'''
	}

	def move(Directive d) {
		val relative = Integer::parseInt(d.instruction.param.split(' ').get(1)) - position
		position = Integer::parseInt(d.instruction.param.split(' ').get(1))
		if(entry1 && entry2) shut = true;
		if(position == 1) entry1 = true;
		if(position == 2) entry2 = true;
		return 'move(' + relative + ');' + shut()
	}

	def shut() {
		if (shut) {
			shut = false;
			entry1 = false;
			entry2 = false;
			return 'shut(0);'
		} else {
			return ''
		}
	}
}
